// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: Linkage

import * as fhir from '../fhir.js';

// @ts-ignore
import { LinkageTypeCodings, LinkageTypeCodingType,} from '../fhirValueSets/LinkageTypeCodings.js';
// @ts-ignore
import { LinkageTypeCodes,  LinkageTypeCodeType } from '../fhirValueSets/LinkageTypeCodes.js';
// @ts-ignore
import { IssueTypeCodes } from '../fhirValueSets/IssueTypeCodes.js';
// @ts-ignore
import { IssueSeverityCodes } from '../fhirValueSets/IssueSeverityCodes.js';
/**
 * Valid arguments for the LinkageItem type.
 */
export interface LinkageItemArgs extends fhir.BackboneElementArgs {
  /**
   * Distinguishes which item is "source of truth" (if any) and which items are no longer considered to be current representations.
   */
  type: LinkageTypeCodeType|null;
  /**
   * The resource instance being linked as part of the group.
   */
  resource: fhir.ReferenceArgs|null;
}

/**
 * Identifies which record considered as the reference to the same real-world occurrence as well as how the items should be evaluated within the collection of linked items.
 */
export class LinkageItem extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static readonly _fts_dataType:string = 'LinkageItem';
  /**
   * Distinguishes which item is "source of truth" (if any) and which items are no longer considered to be current representations.
   */
  public type: LinkageTypeCodeType|null;
  /**
   * The resource instance being linked as part of the group.
   */
  public resource: fhir.Reference|null;
  /**
   * Default constructor for LinkageItem - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<LinkageItemArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = source.type; }
    else { this.type = null; }
    if (source['resource']) { this.resource = new fhir.Reference(source.resource); }
    else { this.resource = null; }
  }
  /**
   * Required-bound Value Set for type (Linkage.item.type)
   */
  public static typeRequiredCoding():LinkageTypeCodingType {
    return LinkageTypeCodings;
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['type']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing,  diagnostics: 'Missing required property type:LinkageTypeCodeType fhir: Linkage.item.type:code', }));
    }
    if (!this['resource']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing,  diagnostics: 'Missing required property resource:fhir.Reference fhir: Linkage.item.resource:Reference', }));
    }
    if (this["resource"]) { outcome.issue!.push(...this.resource.doModelValidation().issue!); }
    return outcome;
  }
}
/**
 * Valid arguments for the Linkage type.
 */
export interface LinkageArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "Linkage"|undefined;
  /**
   * If false, any asserted linkages should not be considered current/relevant/applicable.
   */
  active?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Identifies the user or organization responsible for asserting the linkages as well as the user or organization who establishes the context in which the nature of each linkage is evaluated.
   */
  author?: fhir.ReferenceArgs|undefined;
  /**
   * Identifies which record considered as the reference to the same real-world occurrence as well as how the items should be evaluated within the collection of linked items.
   */
  item: fhir.LinkageItemArgs[]|null;
}

/**
 * Identifies two or more records (resource instances) that refer to the same real-world "occurrence".
 */
export class Linkage extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static readonly _fts_dataType:string = 'Linkage';
  /**
   * Resource Type Name
   */
  public resourceType: "Linkage";
  /**
   * If false, any asserted linkages should not be considered current/relevant/applicable.
   */
  public active?: fhir.FhirBoolean|undefined;
  /**
   * Identifies the user or organization responsible for asserting the linkages as well as the user or organization who establishes the context in which the nature of each linkage is evaluated.
   */
  public author?: fhir.Reference|undefined;
  /**
   * Identifies which record considered as the reference to the same real-world occurrence as well as how the items should be evaluated within the collection of linked items.
   */
  public item: fhir.LinkageItem[];
  /**
   * Default constructor for Linkage - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<LinkageArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'Linkage';
    if (source['active']) { this.active = new fhir.FhirBoolean({value: source.active}); }
    if (source['author']) { this.author = new fhir.Reference(source.author); }
    if (source['item']) { this.item = source.item.map((x) => new fhir.LinkageItem(x)); }
    else { this.item = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.OperationOutcome {
    var outcome:fhir.OperationOutcome = super.doModelValidation();
    if (!this['resourceType']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing,  diagnostics: 'Missing required property resourceType:"Linkage" fhir: Linkage.resourceType:"Linkage"', }));
    }
    if (this["active"]) { outcome.issue!.push(...this.active.doModelValidation().issue!); }
    if (this["author"]) { outcome.issue!.push(...this.author.doModelValidation().issue!); }
    if (!this['item']) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing,  diagnostics: 'Missing required property item:fhir.LinkageItem[] fhir: Linkage.item:item', }));
    } else if (!Array.isArray(this.item)) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.StructuralIssue,  diagnostics: 'Found scalar in array property item:fhir.LinkageItem[] fhir: Linkage.item:item', }));
    } else if (this.item.length === 0) {
      outcome.issue!.push(new fhir.OperationOutcomeIssue({ severity: IssueSeverityCodes.Error, code: IssueTypeCodes.RequiredElementMissing,  diagnostics: 'Missing required property item:fhir.LinkageItem[] fhir: Linkage.item:item', }));
    }
    if (this["item"]) { this.item.forEach((x) => { outcome.issue!.push(...x.doModelValidation().issue!); }) }
    return outcome;
  }
}
