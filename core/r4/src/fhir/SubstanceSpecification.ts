// <auto-generated/>
// Contents of: hl7.fhir.r4.core version: 4.0.1
// Minimum TypeScript Version: 3.7
// FHIR Resource: SubstanceSpecification

import * as fhir from '../fhir.js';

/**
 * Valid arguments for the SubstanceSpecificationMoiety type.
 */
export interface SubstanceSpecificationMoietyArgs extends fhir.BackboneElementArgs {
  /**
   * Role that the moiety is playing.
   */
  role?: fhir.CodeableConceptArgs|undefined;
  /**
   * Identifier by which this moiety substance is known.
   */
  identifier?: fhir.IdentifierArgs|undefined;
  /**
   * Textual name for this moiety substance.
   */
  name?: fhir.FhirString|string|undefined;
  /**
   * Stereochemistry type.
   */
  stereochemistry?: fhir.CodeableConceptArgs|undefined;
  /**
   * Optical activity type.
   */
  opticalActivity?: fhir.CodeableConceptArgs|undefined;
  /**
   * Molecular formula.
   */
  molecularFormula?: fhir.FhirString|string|undefined;
  /**
   * Quantitative value for this moiety.
   */
  amount?: fhir.Quantity|fhir.FhirString|undefined;
  /**
   * Quantitative value for this moiety.
   */
  amountQuantity?: fhir.QuantityArgs|undefined;
  /**
   * Quantitative value for this moiety.
   */
  amountString?: fhir.FhirString|string|undefined;
}

/**
 * Moiety, for structural modifications.
 */
export class SubstanceSpecificationMoiety extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceSpecificationMoiety';
  /**
   * Role that the moiety is playing.
   */
  public role?: fhir.CodeableConcept|undefined;
  /**
   * Identifier by which this moiety substance is known.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * Textual name for this moiety substance.
   */
  public name?: fhir.FhirString|undefined;
  /**
   * Stereochemistry type.
   */
  public stereochemistry?: fhir.CodeableConcept|undefined;
  /**
   * Optical activity type.
   */
  public opticalActivity?: fhir.CodeableConcept|undefined;
  /**
   * Molecular formula.
   */
  public molecularFormula?: fhir.FhirString|undefined;
  /**
   * Quantitative value for this moiety.
   */
  public amount?: (fhir.Quantity|fhir.FhirString)|undefined;
  /**
   * Internal flag to properly serialize choice-type element SubstanceSpecification.moiety.amount[x]
   */
  protected static readonly _fts_amountIsChoice:true = true;
  /**
   * Default constructor for SubstanceSpecificationMoiety - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceSpecificationMoietyArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['role']) { this.role = new fhir.CodeableConcept(source.role); }
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier); }
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    if (source['stereochemistry']) { this.stereochemistry = new fhir.CodeableConcept(source.stereochemistry); }
    if (source['opticalActivity']) { this.opticalActivity = new fhir.CodeableConcept(source.opticalActivity); }
    if (source['molecularFormula']) { this.molecularFormula = new fhir.FhirString({value: source.molecularFormula}); }
    if (source['amount']) { this.amount = source.amount; }
    else if (source['amountQuantity']) { this.amount = new fhir.Quantity(source.amountQuantity); }
    else if (source['amountString']) { this.amount = new fhir.FhirString({value: source.amountString}); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation();
    if (this["role"]) { issues.push(...this.role.doModelValidation()); }
    if (this["identifier"]) { issues.push(...this.identifier.doModelValidation()); }
    if (this["name"]) { issues.push(...this.name.doModelValidation()); }
    if (this["stereochemistry"]) { issues.push(...this.stereochemistry.doModelValidation()); }
    if (this["opticalActivity"]) { issues.push(...this.opticalActivity.doModelValidation()); }
    if (this["molecularFormula"]) { issues.push(...this.molecularFormula.doModelValidation()); }
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceSpecificationProperty type.
 */
export interface SubstanceSpecificationPropertyArgs extends fhir.BackboneElementArgs {
  /**
   * A category for this property, e.g. Physical, Chemical, Enzymatic.
   */
  category?: fhir.CodeableConceptArgs|undefined;
  /**
   * Property type e.g. viscosity, pH, isoelectric point.
   */
  code?: fhir.CodeableConceptArgs|undefined;
  /**
   * Parameters that were used in the measurement of a property (e.g. for viscosity: measured at 20C with a pH of 7.1).
   */
  parameters?: fhir.FhirString|string|undefined;
  /**
   * A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol).
   */
  definingSubstance?: fhir.Reference|fhir.CodeableConcept|undefined;
  /**
   * A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol).
   */
  definingSubstanceReference?: fhir.ReferenceArgs|undefined;
  /**
   * A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol).
   */
  definingSubstanceCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * Quantitative value for this property.
   */
  amount?: fhir.Quantity|fhir.FhirString|undefined;
  /**
   * Quantitative value for this property.
   */
  amountQuantity?: fhir.QuantityArgs|undefined;
  /**
   * Quantitative value for this property.
   */
  amountString?: fhir.FhirString|string|undefined;
}

/**
 * General specifications for this substance, including how it is related to other substances.
 */
export class SubstanceSpecificationProperty extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceSpecificationProperty';
  /**
   * A category for this property, e.g. Physical, Chemical, Enzymatic.
   */
  public category?: fhir.CodeableConcept|undefined;
  /**
   * Property type e.g. viscosity, pH, isoelectric point.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * Parameters that were used in the measurement of a property (e.g. for viscosity: measured at 20C with a pH of 7.1).
   */
  public parameters?: fhir.FhirString|undefined;
  /**
   * A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol).
   */
  public definingSubstance?: (fhir.Reference|fhir.CodeableConcept)|undefined;
  /**
   * Internal flag to properly serialize choice-type element SubstanceSpecification.property.definingSubstance[x]
   */
  protected static readonly _fts_definingSubstanceIsChoice:true = true;
  /**
   * Quantitative value for this property.
   */
  public amount?: (fhir.Quantity|fhir.FhirString)|undefined;
  /**
   * Internal flag to properly serialize choice-type element SubstanceSpecification.property.amount[x]
   */
  protected static readonly _fts_amountIsChoice:true = true;
  /**
   * Default constructor for SubstanceSpecificationProperty - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceSpecificationPropertyArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['category']) { this.category = new fhir.CodeableConcept(source.category); }
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    if (source['parameters']) { this.parameters = new fhir.FhirString({value: source.parameters}); }
    if (source['definingSubstance']) { this.definingSubstance = source.definingSubstance; }
    else if (source['definingSubstanceReference']) { this.definingSubstance = new fhir.Reference(source.definingSubstanceReference); }
    else if (source['definingSubstanceCodeableConcept']) { this.definingSubstance = new fhir.CodeableConcept(source.definingSubstanceCodeableConcept); }
    if (source['amount']) { this.amount = source.amount; }
    else if (source['amountQuantity']) { this.amount = new fhir.Quantity(source.amountQuantity); }
    else if (source['amountString']) { this.amount = new fhir.FhirString({value: source.amountString}); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation();
    if (this["category"]) { issues.push(...this.category.doModelValidation()); }
    if (this["code"]) { issues.push(...this.code.doModelValidation()); }
    if (this["parameters"]) { issues.push(...this.parameters.doModelValidation()); }
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceSpecificationStructureIsotopeMolecularWeight type.
 */
export interface SubstanceSpecificationStructureIsotopeMolecularWeightArgs extends fhir.BackboneElementArgs {
  /**
   * The method by which the molecular weight was determined.
   */
  method?: fhir.CodeableConceptArgs|undefined;
  /**
   * Type of molecular weight such as exact, average (also known as. number average), weight average.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
   */
  amount?: fhir.QuantityArgs|undefined;
}

/**
 * The molecular weight or weight range (for proteins, polymers or nucleic acids).
 */
export class SubstanceSpecificationStructureIsotopeMolecularWeight extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceSpecificationStructureIsotopeMolecularWeight';
  /**
   * The method by which the molecular weight was determined.
   */
  public method?: fhir.CodeableConcept|undefined;
  /**
   * Type of molecular weight such as exact, average (also known as. number average), weight average.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
   */
  public amount?: fhir.Quantity|undefined;
  /**
   * Default constructor for SubstanceSpecificationStructureIsotopeMolecularWeight - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceSpecificationStructureIsotopeMolecularWeightArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['method']) { this.method = new fhir.CodeableConcept(source.method); }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['amount']) { this.amount = new fhir.Quantity(source.amount); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation();
    if (this["method"]) { issues.push(...this.method.doModelValidation()); }
    if (this["type"]) { issues.push(...this.type.doModelValidation()); }
    if (this["amount"]) { issues.push(...this.amount.doModelValidation()); }
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceSpecificationStructureIsotope type.
 */
export interface SubstanceSpecificationStructureIsotopeArgs extends fhir.BackboneElementArgs {
  /**
   * Substance identifier for each non-natural or radioisotope.
   */
  identifier?: fhir.IdentifierArgs|undefined;
  /**
   * Substance name for each non-natural or radioisotope.
   */
  name?: fhir.CodeableConceptArgs|undefined;
  /**
   * The type of isotopic substitution present in a single substance.
   */
  substitution?: fhir.CodeableConceptArgs|undefined;
  /**
   * Half life - for a non-natural nuclide.
   */
  halfLife?: fhir.QuantityArgs|undefined;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  molecularWeight?: fhir.SubstanceSpecificationStructureIsotopeMolecularWeightArgs|undefined;
}

/**
 * Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio.
 */
export class SubstanceSpecificationStructureIsotope extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceSpecificationStructureIsotope';
  /**
   * Substance identifier for each non-natural or radioisotope.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * Substance name for each non-natural or radioisotope.
   */
  public name?: fhir.CodeableConcept|undefined;
  /**
   * The type of isotopic substitution present in a single substance.
   */
  public substitution?: fhir.CodeableConcept|undefined;
  /**
   * Half life - for a non-natural nuclide.
   */
  public halfLife?: fhir.Quantity|undefined;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  public molecularWeight?: fhir.SubstanceSpecificationStructureIsotopeMolecularWeight|undefined;
  /**
   * Default constructor for SubstanceSpecificationStructureIsotope - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceSpecificationStructureIsotopeArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier); }
    if (source['name']) { this.name = new fhir.CodeableConcept(source.name); }
    if (source['substitution']) { this.substitution = new fhir.CodeableConcept(source.substitution); }
    if (source['halfLife']) { this.halfLife = new fhir.Quantity(source.halfLife); }
    if (source['molecularWeight']) { this.molecularWeight = new fhir.SubstanceSpecificationStructureIsotopeMolecularWeight(source.molecularWeight); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation();
    if (this["identifier"]) { issues.push(...this.identifier.doModelValidation()); }
    if (this["name"]) { issues.push(...this.name.doModelValidation()); }
    if (this["substitution"]) { issues.push(...this.substitution.doModelValidation()); }
    if (this["halfLife"]) { issues.push(...this.halfLife.doModelValidation()); }
    if (this["molecularWeight"]) { issues.push(...this.molecularWeight.doModelValidation()); }
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceSpecificationStructureRepresentation type.
 */
export interface SubstanceSpecificationStructureRepresentationArgs extends fhir.BackboneElementArgs {
  /**
   * The type of structure (e.g. Full, Partial, Representative).
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * The structural representation as text string in a format e.g. InChI, SMILES, MOLFILE, CDX.
   */
  representation?: fhir.FhirString|string|undefined;
  /**
   * An attached file with the structural representation.
   */
  attachment?: fhir.AttachmentArgs|undefined;
}

/**
 * Molecular structural representation.
 */
export class SubstanceSpecificationStructureRepresentation extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceSpecificationStructureRepresentation';
  /**
   * The type of structure (e.g. Full, Partial, Representative).
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * The structural representation as text string in a format e.g. InChI, SMILES, MOLFILE, CDX.
   */
  public representation?: fhir.FhirString|undefined;
  /**
   * An attached file with the structural representation.
   */
  public attachment?: fhir.Attachment|undefined;
  /**
   * Default constructor for SubstanceSpecificationStructureRepresentation - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceSpecificationStructureRepresentationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['representation']) { this.representation = new fhir.FhirString({value: source.representation}); }
    if (source['attachment']) { this.attachment = new fhir.Attachment(source.attachment); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation();
    if (this["type"]) { issues.push(...this.type.doModelValidation()); }
    if (this["representation"]) { issues.push(...this.representation.doModelValidation()); }
    if (this["attachment"]) { issues.push(...this.attachment.doModelValidation()); }
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceSpecificationStructure type.
 */
export interface SubstanceSpecificationStructureArgs extends fhir.BackboneElementArgs {
  /**
   * Stereochemistry type.
   */
  stereochemistry?: fhir.CodeableConceptArgs|undefined;
  /**
   * Optical activity type.
   */
  opticalActivity?: fhir.CodeableConceptArgs|undefined;
  /**
   * Molecular formula.
   */
  molecularFormula?: fhir.FhirString|string|undefined;
  /**
   * Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
   */
  molecularFormulaByMoiety?: fhir.FhirString|string|undefined;
  /**
   * Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio.
   */
  isotope?: fhir.SubstanceSpecificationStructureIsotopeArgs[]|undefined;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  molecularWeight?: fhir.SubstanceSpecificationStructureIsotopeMolecularWeightArgs|undefined;
  /**
   * Supporting literature.
   */
  source?: fhir.ReferenceArgs[]|undefined;
  /**
   * Molecular structural representation.
   */
  representation?: fhir.SubstanceSpecificationStructureRepresentationArgs[]|undefined;
}

/**
 * Structural information.
 */
export class SubstanceSpecificationStructure extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceSpecificationStructure';
  /**
   * Stereochemistry type.
   */
  public stereochemistry?: fhir.CodeableConcept|undefined;
  /**
   * Optical activity type.
   */
  public opticalActivity?: fhir.CodeableConcept|undefined;
  /**
   * Molecular formula.
   */
  public molecularFormula?: fhir.FhirString|undefined;
  /**
   * Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
   */
  public molecularFormulaByMoiety?: fhir.FhirString|undefined;
  /**
   * Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio.
   */
  public isotope: fhir.SubstanceSpecificationStructureIsotope[];
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  public molecularWeight?: fhir.SubstanceSpecificationStructureIsotopeMolecularWeight|undefined;
  /**
   * Supporting literature.
   */
  public source: fhir.Reference[];
  /**
   * Molecular structural representation.
   */
  public representation: fhir.SubstanceSpecificationStructureRepresentation[];
  /**
   * Default constructor for SubstanceSpecificationStructure - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceSpecificationStructureArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['stereochemistry']) { this.stereochemistry = new fhir.CodeableConcept(source.stereochemistry); }
    if (source['opticalActivity']) { this.opticalActivity = new fhir.CodeableConcept(source.opticalActivity); }
    if (source['molecularFormula']) { this.molecularFormula = new fhir.FhirString({value: source.molecularFormula}); }
    if (source['molecularFormulaByMoiety']) { this.molecularFormulaByMoiety = new fhir.FhirString({value: source.molecularFormulaByMoiety}); }
    if (source['isotope']) { this.isotope = source.isotope.map((x) => new fhir.SubstanceSpecificationStructureIsotope(x)); }
    else { this.isotope = []; }
    if (source['molecularWeight']) { this.molecularWeight = new fhir.SubstanceSpecificationStructureIsotopeMolecularWeight(source.molecularWeight); }
    if (source['source']) { this.source = source.source.map((x) => new fhir.Reference(x)); }
    else { this.source = []; }
    if (source['representation']) { this.representation = source.representation.map((x) => new fhir.SubstanceSpecificationStructureRepresentation(x)); }
    else { this.representation = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation();
    if (this["stereochemistry"]) { issues.push(...this.stereochemistry.doModelValidation()); }
    if (this["opticalActivity"]) { issues.push(...this.opticalActivity.doModelValidation()); }
    if (this["molecularFormula"]) { issues.push(...this.molecularFormula.doModelValidation()); }
    if (this["molecularFormulaByMoiety"]) { issues.push(...this.molecularFormulaByMoiety.doModelValidation()); }
    if (this["isotope"]) { this.isotope.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["molecularWeight"]) { issues.push(...this.molecularWeight.doModelValidation()); }
    if (this["source"]) { this.source.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["representation"]) { this.representation.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceSpecificationCode type.
 */
export interface SubstanceSpecificationCodeArgs extends fhir.BackboneElementArgs {
  /**
   * The specific code.
   */
  code?: fhir.CodeableConceptArgs|undefined;
  /**
   * Status of the code assignment.
   */
  status?: fhir.CodeableConceptArgs|undefined;
  /**
   * The date at which the code status is changed as part of the terminology maintenance.
   */
  statusDate?: fhir.FhirDateTime|string|undefined;
  /**
   * Any comment can be provided in this field, if necessary.
   */
  comment?: fhir.FhirString|string|undefined;
  /**
   * Supporting literature.
   */
  source?: fhir.ReferenceArgs[]|undefined;
}

/**
 * Codes associated with the substance.
 */
export class SubstanceSpecificationCode extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceSpecificationCode';
  /**
   * The specific code.
   */
  public code?: fhir.CodeableConcept|undefined;
  /**
   * Status of the code assignment.
   */
  public status?: fhir.CodeableConcept|undefined;
  /**
   * The date at which the code status is changed as part of the terminology maintenance.
   */
  public statusDate?: fhir.FhirDateTime|undefined;
  /**
   * Any comment can be provided in this field, if necessary.
   */
  public comment?: fhir.FhirString|undefined;
  /**
   * Supporting literature.
   */
  public source: fhir.Reference[];
  /**
   * Default constructor for SubstanceSpecificationCode - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceSpecificationCodeArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['code']) { this.code = new fhir.CodeableConcept(source.code); }
    if (source['status']) { this.status = new fhir.CodeableConcept(source.status); }
    if (source['statusDate']) { this.statusDate = new fhir.FhirDateTime({value: source.statusDate}); }
    if (source['comment']) { this.comment = new fhir.FhirString({value: source.comment}); }
    if (source['source']) { this.source = source.source.map((x) => new fhir.Reference(x)); }
    else { this.source = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation();
    if (this["code"]) { issues.push(...this.code.doModelValidation()); }
    if (this["status"]) { issues.push(...this.status.doModelValidation()); }
    if (this["statusDate"]) { issues.push(...this.statusDate.doModelValidation()); }
    if (this["comment"]) { issues.push(...this.comment.doModelValidation()); }
    if (this["source"]) { this.source.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceSpecificationNameOfficial type.
 */
export interface SubstanceSpecificationNameOfficialArgs extends fhir.BackboneElementArgs {
  /**
   * Which authority uses this official name.
   */
  authority?: fhir.CodeableConceptArgs|undefined;
  /**
   * The status of the official name.
   */
  status?: fhir.CodeableConceptArgs|undefined;
  /**
   * Date of official name change.
   */
  date?: fhir.FhirDateTime|string|undefined;
}

/**
 * Details of the official nature of this name.
 */
export class SubstanceSpecificationNameOfficial extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceSpecificationNameOfficial';
  /**
   * Which authority uses this official name.
   */
  public authority?: fhir.CodeableConcept|undefined;
  /**
   * The status of the official name.
   */
  public status?: fhir.CodeableConcept|undefined;
  /**
   * Date of official name change.
   */
  public date?: fhir.FhirDateTime|undefined;
  /**
   * Default constructor for SubstanceSpecificationNameOfficial - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceSpecificationNameOfficialArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['authority']) { this.authority = new fhir.CodeableConcept(source.authority); }
    if (source['status']) { this.status = new fhir.CodeableConcept(source.status); }
    if (source['date']) { this.date = new fhir.FhirDateTime({value: source.date}); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation();
    if (this["authority"]) { issues.push(...this.authority.doModelValidation()); }
    if (this["status"]) { issues.push(...this.status.doModelValidation()); }
    if (this["date"]) { issues.push(...this.date.doModelValidation()); }
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceSpecificationName type.
 */
export interface SubstanceSpecificationNameArgs extends fhir.BackboneElementArgs {
  /**
   * The actual name.
   */
  name: fhir.FhirString|string|undefined;
  /**
   * Name type.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * The status of the name.
   */
  status?: fhir.CodeableConceptArgs|undefined;
  /**
   * If this is the preferred name for this substance.
   */
  preferred?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Language of the name.
   */
  language?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
   */
  domain?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The jurisdiction where this name applies.
   */
  jurisdiction?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * A synonym of this name.
   */
  synonym?: fhir.SubstanceSpecificationNameArgs[]|undefined;
  /**
   * A translation for this name.
   */
  translation?: fhir.SubstanceSpecificationNameArgs[]|undefined;
  /**
   * Details of the official nature of this name.
   */
  official?: fhir.SubstanceSpecificationNameOfficialArgs[]|undefined;
  /**
   * Supporting literature.
   */
  source?: fhir.ReferenceArgs[]|undefined;
}

/**
 * Names applicable to this substance.
 */
export class SubstanceSpecificationName extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceSpecificationName';
  /**
   * The actual name.
   */
  public name: fhir.FhirString|null;
  /**
   * Name type.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * The status of the name.
   */
  public status?: fhir.CodeableConcept|undefined;
  /**
   * If this is the preferred name for this substance.
   */
  public preferred?: fhir.FhirBoolean|undefined;
  /**
   * Language of the name.
   */
  public language: fhir.CodeableConcept[];
  /**
   * The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
   */
  public domain: fhir.CodeableConcept[];
  /**
   * The jurisdiction where this name applies.
   */
  public jurisdiction: fhir.CodeableConcept[];
  /**
   * A synonym of this name.
   */
  public synonym: fhir.SubstanceSpecificationName[];
  /**
   * A translation for this name.
   */
  public translation: fhir.SubstanceSpecificationName[];
  /**
   * Details of the official nature of this name.
   */
  public official: fhir.SubstanceSpecificationNameOfficial[];
  /**
   * Supporting literature.
   */
  public source: fhir.Reference[];
  /**
   * Default constructor for SubstanceSpecificationName - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceSpecificationNameArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['name']) { this.name = new fhir.FhirString({value: source.name}); }
    else { this.name = null; }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['status']) { this.status = new fhir.CodeableConcept(source.status); }
    if (source['preferred']) { this.preferred = new fhir.FhirBoolean({value: source.preferred}); }
    if (source['language']) { this.language = source.language.map((x) => new fhir.CodeableConcept(x)); }
    else { this.language = []; }
    if (source['domain']) { this.domain = source.domain.map((x) => new fhir.CodeableConcept(x)); }
    else { this.domain = []; }
    if (source['jurisdiction']) { this.jurisdiction = source.jurisdiction.map((x) => new fhir.CodeableConcept(x)); }
    else { this.jurisdiction = []; }
    if (source['synonym']) { this.synonym = source.synonym.map((x) => new fhir.SubstanceSpecificationName(x)); }
    else { this.synonym = []; }
    if (source['translation']) { this.translation = source.translation.map((x) => new fhir.SubstanceSpecificationName(x)); }
    else { this.translation = []; }
    if (source['official']) { this.official = source.official.map((x) => new fhir.SubstanceSpecificationNameOfficial(x)); }
    else { this.official = []; }
    if (source['source']) { this.source = source.source.map((x) => new fhir.Reference(x)); }
    else { this.source = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation();
    if (!this['name']) {
      issues.push({ severity: 'error', code: 'required', diagnostics: 'Missing required property name:fhir.FhirString fhir: SubstanceSpecification.name.name:string' });
    }
    if (this["name"]) { issues.push(...this.name.doModelValidation()); }
    if (this["type"]) { issues.push(...this.type.doModelValidation()); }
    if (this["status"]) { issues.push(...this.status.doModelValidation()); }
    if (this["preferred"]) { issues.push(...this.preferred.doModelValidation()); }
    if (this["language"]) { this.language.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["domain"]) { this.domain.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["jurisdiction"]) { this.jurisdiction.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["synonym"]) { this.synonym.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["translation"]) { this.translation.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["official"]) { this.official.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["source"]) { this.source.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceSpecificationRelationship type.
 */
export interface SubstanceSpecificationRelationshipArgs extends fhir.BackboneElementArgs {
  /**
   * A pointer to another substance, as a resource or just a representational code.
   */
  substance?: fhir.Reference|fhir.CodeableConcept|undefined;
  /**
   * A pointer to another substance, as a resource or just a representational code.
   */
  substanceReference?: fhir.ReferenceArgs|undefined;
  /**
   * A pointer to another substance, as a resource or just a representational code.
   */
  substanceCodeableConcept?: fhir.CodeableConceptArgs|undefined;
  /**
   * For example "salt to parent", "active moiety", "starting material".
   */
  relationship?: fhir.CodeableConceptArgs|undefined;
  /**
   * For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
   */
  isDefining?: fhir.FhirBoolean|boolean|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amount?: fhir.Quantity|fhir.Range|fhir.Ratio|fhir.FhirString|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountQuantity?: fhir.QuantityArgs|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountRange?: fhir.RangeArgs|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountRatio?: fhir.RatioArgs|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  amountString?: fhir.FhirString|string|undefined;
  /**
   * For use when the numeric.
   */
  amountRatioLowLimit?: fhir.RatioArgs|undefined;
  /**
   * An operator for the amount, for example "average", "approximately", "less than".
   */
  amountType?: fhir.CodeableConceptArgs|undefined;
  /**
   * Supporting literature.
   */
  source?: fhir.ReferenceArgs[]|undefined;
}

/**
 * A link between this substance and another, with details of the relationship.
 */
export class SubstanceSpecificationRelationship extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceSpecificationRelationship';
  /**
   * A pointer to another substance, as a resource or just a representational code.
   */
  public substance?: (fhir.Reference|fhir.CodeableConcept)|undefined;
  /**
   * Internal flag to properly serialize choice-type element SubstanceSpecification.relationship.substance[x]
   */
  protected static readonly _fts_substanceIsChoice:true = true;
  /**
   * For example "salt to parent", "active moiety", "starting material".
   */
  public relationship?: fhir.CodeableConcept|undefined;
  /**
   * For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
   */
  public isDefining?: fhir.FhirBoolean|undefined;
  /**
   * A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
   */
  public amount?: (fhir.Quantity|fhir.Range|fhir.Ratio|fhir.FhirString)|undefined;
  /**
   * Internal flag to properly serialize choice-type element SubstanceSpecification.relationship.amount[x]
   */
  protected static readonly _fts_amountIsChoice:true = true;
  /**
   * For use when the numeric.
   */
  public amountRatioLowLimit?: fhir.Ratio|undefined;
  /**
   * An operator for the amount, for example "average", "approximately", "less than".
   */
  public amountType?: fhir.CodeableConcept|undefined;
  /**
   * Supporting literature.
   */
  public source: fhir.Reference[];
  /**
   * Default constructor for SubstanceSpecificationRelationship - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceSpecificationRelationshipArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['substance']) { this.substance = source.substance; }
    else if (source['substanceReference']) { this.substance = new fhir.Reference(source.substanceReference); }
    else if (source['substanceCodeableConcept']) { this.substance = new fhir.CodeableConcept(source.substanceCodeableConcept); }
    if (source['relationship']) { this.relationship = new fhir.CodeableConcept(source.relationship); }
    if (source['isDefining']) { this.isDefining = new fhir.FhirBoolean({value: source.isDefining}); }
    if (source['amount']) { this.amount = source.amount; }
    else if (source['amountQuantity']) { this.amount = new fhir.Quantity(source.amountQuantity); }
    else if (source['amountRange']) { this.amount = new fhir.Range(source.amountRange); }
    else if (source['amountRatio']) { this.amount = new fhir.Ratio(source.amountRatio); }
    else if (source['amountString']) { this.amount = new fhir.FhirString({value: source.amountString}); }
    if (source['amountRatioLowLimit']) { this.amountRatioLowLimit = new fhir.Ratio(source.amountRatioLowLimit); }
    if (source['amountType']) { this.amountType = new fhir.CodeableConcept(source.amountType); }
    if (source['source']) { this.source = source.source.map((x) => new fhir.Reference(x)); }
    else { this.source = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation();
    if (this["relationship"]) { issues.push(...this.relationship.doModelValidation()); }
    if (this["isDefining"]) { issues.push(...this.isDefining.doModelValidation()); }
    if (this["amountRatioLowLimit"]) { issues.push(...this.amountRatioLowLimit.doModelValidation()); }
    if (this["amountType"]) { issues.push(...this.amountType.doModelValidation()); }
    if (this["source"]) { this.source.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    return issues;
  }
}
/**
 * Valid arguments for the SubstanceSpecification type.
 */
export interface SubstanceSpecificationArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "SubstanceSpecification"|undefined;
  /**
   * Identifier by which this substance is known.
   */
  identifier?: fhir.IdentifierArgs|undefined;
  /**
   * High level categorization, e.g. polymer or nucleic acid.
   */
  type?: fhir.CodeableConceptArgs|undefined;
  /**
   * Status of substance within the catalogue e.g. approved.
   */
  status?: fhir.CodeableConceptArgs|undefined;
  /**
   * If the substance applies to only human or veterinary use.
   */
  domain?: fhir.CodeableConceptArgs|undefined;
  /**
   * Textual description of the substance.
   */
  description?: fhir.FhirString|string|undefined;
  /**
   * Supporting literature.
   */
  source?: fhir.ReferenceArgs[]|undefined;
  /**
   * Textual comment about this record of a substance.
   */
  comment?: fhir.FhirString|string|undefined;
  /**
   * Moiety, for structural modifications.
   */
  moiety?: fhir.SubstanceSpecificationMoietyArgs[]|undefined;
  /**
   * General specifications for this substance, including how it is related to other substances.
   */
  property?: fhir.SubstanceSpecificationPropertyArgs[]|undefined;
  /**
   * General information detailing this substance.
   */
  referenceInformation?: fhir.ReferenceArgs|undefined;
  /**
   * Structural information.
   */
  structure?: fhir.SubstanceSpecificationStructureArgs|undefined;
  /**
   * Codes associated with the substance.
   */
  code?: fhir.SubstanceSpecificationCodeArgs[]|undefined;
  /**
   * Names applicable to this substance.
   */
  name?: fhir.SubstanceSpecificationNameArgs[]|undefined;
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  molecularWeight?: fhir.SubstanceSpecificationStructureIsotopeMolecularWeightArgs[]|undefined;
  /**
   * A link between this substance and another, with details of the relationship.
   */
  relationship?: fhir.SubstanceSpecificationRelationshipArgs[]|undefined;
  /**
   * Data items specific to nucleic acids.
   */
  nucleicAcid?: fhir.ReferenceArgs|undefined;
  /**
   * Data items specific to polymers.
   */
  polymer?: fhir.ReferenceArgs|undefined;
  /**
   * Data items specific to proteins.
   */
  protein?: fhir.ReferenceArgs|undefined;
  /**
   * Material or taxonomic/anatomical source for the substance.
   */
  sourceMaterial?: fhir.ReferenceArgs|undefined;
}

/**
 * The detailed description of a substance, typically at a level beyond what is used for prescribing.
 */
export class SubstanceSpecification extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'SubstanceSpecification';
  /**
   * Resource Type Name
   */
  public override resourceType: "SubstanceSpecification";
  /**
   * Identifier by which this substance is known.
   */
  public identifier?: fhir.Identifier|undefined;
  /**
   * High level categorization, e.g. polymer or nucleic acid.
   */
  public type?: fhir.CodeableConcept|undefined;
  /**
   * Status of substance within the catalogue e.g. approved.
   */
  public status?: fhir.CodeableConcept|undefined;
  /**
   * If the substance applies to only human or veterinary use.
   */
  public domain?: fhir.CodeableConcept|undefined;
  /**
   * Textual description of the substance.
   */
  public description?: fhir.FhirString|undefined;
  /**
   * Supporting literature.
   */
  public source: fhir.Reference[];
  /**
   * Textual comment about this record of a substance.
   */
  public comment?: fhir.FhirString|undefined;
  /**
   * Moiety, for structural modifications.
   */
  public moiety: fhir.SubstanceSpecificationMoiety[];
  /**
   * General specifications for this substance, including how it is related to other substances.
   */
  public property: fhir.SubstanceSpecificationProperty[];
  /**
   * General information detailing this substance.
   */
  public referenceInformation?: fhir.Reference|undefined;
  /**
   * Structural information.
   */
  public structure?: fhir.SubstanceSpecificationStructure|undefined;
  /**
   * Codes associated with the substance.
   */
  public code: fhir.SubstanceSpecificationCode[];
  /**
   * Names applicable to this substance.
   */
  public name: fhir.SubstanceSpecificationName[];
  /**
   * The molecular weight or weight range (for proteins, polymers or nucleic acids).
   */
  public molecularWeight: fhir.SubstanceSpecificationStructureIsotopeMolecularWeight[];
  /**
   * A link between this substance and another, with details of the relationship.
   */
  public relationship: fhir.SubstanceSpecificationRelationship[];
  /**
   * Data items specific to nucleic acids.
   */
  public nucleicAcid?: fhir.Reference|undefined;
  /**
   * Data items specific to polymers.
   */
  public polymer?: fhir.Reference|undefined;
  /**
   * Data items specific to proteins.
   */
  public protein?: fhir.Reference|undefined;
  /**
   * Material or taxonomic/anatomical source for the substance.
   */
  public sourceMaterial?: fhir.Reference|undefined;
  /**
   * Default constructor for SubstanceSpecification - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<SubstanceSpecificationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'SubstanceSpecification';
    if (source['identifier']) { this.identifier = new fhir.Identifier(source.identifier); }
    if (source['type']) { this.type = new fhir.CodeableConcept(source.type); }
    if (source['status']) { this.status = new fhir.CodeableConcept(source.status); }
    if (source['domain']) { this.domain = new fhir.CodeableConcept(source.domain); }
    if (source['description']) { this.description = new fhir.FhirString({value: source.description}); }
    if (source['source']) { this.source = source.source.map((x) => new fhir.Reference(x)); }
    else { this.source = []; }
    if (source['comment']) { this.comment = new fhir.FhirString({value: source.comment}); }
    if (source['moiety']) { this.moiety = source.moiety.map((x) => new fhir.SubstanceSpecificationMoiety(x)); }
    else { this.moiety = []; }
    if (source['property']) { this.property = source.property.map((x) => new fhir.SubstanceSpecificationProperty(x)); }
    else { this.property = []; }
    if (source['referenceInformation']) { this.referenceInformation = new fhir.Reference(source.referenceInformation); }
    if (source['structure']) { this.structure = new fhir.SubstanceSpecificationStructure(source.structure); }
    if (source['code']) { this.code = source.code.map((x) => new fhir.SubstanceSpecificationCode(x)); }
    else { this.code = []; }
    if (source['name']) { this.name = source.name.map((x) => new fhir.SubstanceSpecificationName(x)); }
    else { this.name = []; }
    if (source['molecularWeight']) { this.molecularWeight = source.molecularWeight.map((x) => new fhir.SubstanceSpecificationStructureIsotopeMolecularWeight(x)); }
    else { this.molecularWeight = []; }
    if (source['relationship']) { this.relationship = source.relationship.map((x) => new fhir.SubstanceSpecificationRelationship(x)); }
    else { this.relationship = []; }
    if (source['nucleicAcid']) { this.nucleicAcid = new fhir.Reference(source.nucleicAcid); }
    if (source['polymer']) { this.polymer = new fhir.Reference(source.polymer); }
    if (source['protein']) { this.protein = new fhir.Reference(source.protein); }
    if (source['sourceMaterial']) { this.sourceMaterial = new fhir.Reference(source.sourceMaterial); }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation():fhir.FtsIssue[] {
    let issues:fhir.FtsIssue[] = super.doModelValidation();
    if (!this['resourceType']) {
      issues.push({ severity: 'error', code: 'required', diagnostics: 'Missing required property resourceType:"SubstanceSpecification" fhir: SubstanceSpecification.resourceType:"SubstanceSpecification"' });
    }
    if (this["identifier"]) { issues.push(...this.identifier.doModelValidation()); }
    if (this["type"]) { issues.push(...this.type.doModelValidation()); }
    if (this["status"]) { issues.push(...this.status.doModelValidation()); }
    if (this["domain"]) { issues.push(...this.domain.doModelValidation()); }
    if (this["description"]) { issues.push(...this.description.doModelValidation()); }
    if (this["source"]) { this.source.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["comment"]) { issues.push(...this.comment.doModelValidation()); }
    if (this["moiety"]) { this.moiety.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["property"]) { this.property.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["referenceInformation"]) { issues.push(...this.referenceInformation.doModelValidation()); }
    if (this["structure"]) { issues.push(...this.structure.doModelValidation()); }
    if (this["code"]) { this.code.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["name"]) { this.name.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["molecularWeight"]) { this.molecularWeight.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["relationship"]) { this.relationship.forEach((x) => { issues.push(...x.doModelValidation()); }) }
    if (this["nucleicAcid"]) { issues.push(...this.nucleicAcid.doModelValidation()); }
    if (this["polymer"]) { issues.push(...this.polymer.doModelValidation()); }
    if (this["protein"]) { issues.push(...this.protein.doModelValidation()); }
    if (this["sourceMaterial"]) { issues.push(...this.sourceMaterial.doModelValidation()); }
    return issues;
  }
}
