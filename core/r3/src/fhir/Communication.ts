// <auto-generated/>
// Contents of: hl7.fhir.r3.core version: 3.0.2
// Minimum TypeScript Version: 3.7
// FHIR Resource: Communication

import * as fhir from '../fhir.js';

// @ts-ignore
import { EventStatusCodes,  EventStatusCodeType } from '../fhirValueSets/EventStatusCodes.js';
// @ts-ignore
import { EventStatusVsValidation } from '../fhirValueSets/EventStatusVsValidation.js';
// @ts-ignore
import { CommunicationNotDoneReasonCodes,  CommunicationNotDoneReasonCodeType } from '../fhirValueSets/CommunicationNotDoneReasonCodes.js';
// @ts-ignore
import { CommunicationNotDoneReasonVsValidation } from '../fhirValueSets/CommunicationNotDoneReasonVsValidation.js';
// @ts-ignore
import { CommunicationCategoryCodes,  CommunicationCategoryCodeType } from '../fhirValueSets/CommunicationCategoryCodes.js';
// @ts-ignore
import { CommunicationCategoryVsValidation } from '../fhirValueSets/CommunicationCategoryVsValidation.js';
// @ts-ignore
import { V3ParticipationModeCodes,  V3ParticipationModeCodeType } from '../fhirValueSets/V3ParticipationModeCodes.js';
// @ts-ignore
import { V3ParticipationModeVsValidation } from '../fhirValueSets/V3ParticipationModeVsValidation.js';
// @ts-ignore
import { ClinicalFindingsCodes,  ClinicalFindingsCodeType } from '../fhirValueSets/ClinicalFindingsCodes.js';
// @ts-ignore
import { ClinicalFindingsVsValidation } from '../fhirValueSets/ClinicalFindingsVsValidation.js';
/**
 * Valid arguments for the CommunicationPayload type.
 */
export interface CommunicationPayloadArgs extends fhir.BackboneElementArgs {
  /**
   * A communicated content (or for multi-part communications, one portion of the communication).
   */
  content?: fhir.FhirString|fhir.Attachment|fhir.Reference|undefined;
  /**
   * A communicated content (or for multi-part communications, one portion of the communication).
   */
  contentString?: fhir.FhirString|string|undefined;
  /**
   * A communicated content (or for multi-part communications, one portion of the communication).
   */
  contentAttachment?: fhir.AttachmentArgs|undefined;
  /**
   * A communicated content (or for multi-part communications, one portion of the communication).
   */
  contentReference?: fhir.ReferenceArgs|undefined;
}

/**
 * Text, attachment(s), or resource(s) that was communicated to the recipient.
 */
export class CommunicationPayload extends fhir.BackboneElement {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'CommunicationPayload';
  /**
   * A communicated content (or for multi-part communications, one portion of the communication).
   */
  public content: (fhir.FhirString|fhir.Attachment|fhir.Reference)|null;
  /**
   * Internal flag to properly serialize choice-type element Communication.payload.content[x]
   */
  protected static readonly _fts_contentIsChoice:true = true;
  /**
   * Default constructor for CommunicationPayload - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<CommunicationPayloadArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    if (source['content']) { this.content = source.content; }
    else if (source['contentString']) { this.content = new fhir.FhirString({value: source.contentString}); }
    else if (source['contentAttachment']) { this.content = new fhir.Attachment(source.contentAttachment); }
    else if (source['contentReference']) { this.content = new fhir.Reference(source.contentReference); }
    else { this.content = null; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Communication.payload' }
    iss.push(...this.vRS('content',exp));
    return iss;
  }
}
/**
 * Valid arguments for the Communication type.
 */
export interface CommunicationArgs extends fhir.DomainResourceArgs {
  /**
   * Resource Type Name
   */
  resourceType: "Communication"|undefined;
  /**
   * Identifiers associated with this Communication that are defined by business processes and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
   */
  identifier?: fhir.IdentifierArgs[]|undefined;
  /**
   * A protocol, guideline, or other definition that was adhered to in whole or in part by this communication event.
   */
  definition?: fhir.ReferenceArgs[]|undefined;
  /**
   * This must point to some sort of a 'Request' resource, such as CarePlan, CommunicationRequest, ReferralRequest, MedicationRequest, etc.
   */
  basedOn?: fhir.ReferenceArgs[]|undefined;
  /**
   * Part of this action.
   */
  partOf?: fhir.ReferenceArgs[]|undefined;
  /**
   * This element is labeled as a modifier because the status contains the codes aborted and entered-in-error that mark the communication as not currently valid.
   */
  status: fhir.FhirCode<EventStatusCodeType>|string|undefined;
  /**
   * Extended properties for primitive element: Communication.status
   */
  _status?:fhir.FhirElementArgs;
  /**
   * This element is labeled as a modifier because it marks the communication as a communication that did not occur.  The more attributes are populated, the more constrained the negated statement is.
   */
  notDone?: fhir.FhirBoolean|boolean|undefined;
  /**
   * Extended properties for primitive element: Communication.notDone
   */
  _notDone?:fhir.FhirElementArgs;
  /**
   * Describes why the communication event did not occur in coded and/or textual form.
   */
  notDoneReason?: fhir.CodeableConceptArgs|undefined;
  /**
   * There may be multiple axes of categorization and one communication may serve multiple purposes.
   */
  category?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * A channel that was used for this communication (e.g. email, fax).
   */
  medium?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * The patient or group that was the focus of this communication.
   */
  subject?: fhir.ReferenceArgs|undefined;
  /**
   * The entity (e.g. person, organization, clinical information system, or device) which was the target of the communication. If receipts need to be tracked by individual, a separate resource instance will need to be created for each recipient.  Multiple recipient communications are intended where either a receipt(s) is not tracked (e.g. a mass mail-out) or is captured in aggregate (all emails confirmed received by a particular time).
   */
  recipient?: fhir.ReferenceArgs[]|undefined;
  /**
   * The resources which were responsible for or related to producing this communication.
   */
  topic?: fhir.ReferenceArgs[]|undefined;
  /**
   * The encounter within which the communication was sent.
   */
  context?: fhir.ReferenceArgs|undefined;
  /**
   * The time when this communication was sent.
   */
  sent?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: Communication.sent
   */
  _sent?:fhir.FhirElementArgs;
  /**
   * The time when this communication arrived at the destination.
   */
  received?: fhir.FhirDateTime|string|undefined;
  /**
   * Extended properties for primitive element: Communication.received
   */
  _received?:fhir.FhirElementArgs;
  /**
   * The entity (e.g. person, organization, clinical information system, or device) which was the source of the communication.
   */
  sender?: fhir.ReferenceArgs|undefined;
  /**
   * Textual reasons can be caprued using reasonCode.text.
   */
  reasonCode?: fhir.CodeableConceptArgs[]|undefined;
  /**
   * Indicates another resource whose existence justifies this communication.
   */
  reasonReference?: fhir.ReferenceArgs[]|undefined;
  /**
   * Text, attachment(s), or resource(s) that was communicated to the recipient.
   */
  payload?: fhir.CommunicationPayloadArgs[]|undefined;
  /**
   * Additional notes or commentary about the communication by the sender, receiver or other interested parties.
   */
  note?: fhir.AnnotationArgs[]|undefined;
}

/**
 * An occurrence of information being transmitted; e.g. an alert that was sent to a responsible provider, a public health agency was notified about a reportable condition.
 */
export class Communication extends fhir.DomainResource {
  /**
   * Mapping of this datatype to a FHIR equivalent
   */
  public static override readonly _fts_dataType:string = 'Communication';
  /**
   * Resource Type Name
   */
  public override resourceType: "Communication";
  /**
   * Identifiers associated with this Communication that are defined by business processes and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
   */
  public identifier: fhir.Identifier[];
  /**
   * A protocol, guideline, or other definition that was adhered to in whole or in part by this communication event.
   */
  public definition: fhir.Reference[];
  /**
   * This must point to some sort of a 'Request' resource, such as CarePlan, CommunicationRequest, ReferralRequest, MedicationRequest, etc.
   */
  public basedOn: fhir.Reference[];
  /**
   * Part of this action.
   */
  public partOf: fhir.Reference[];
  /**
   * This element is labeled as a modifier because the status contains the codes aborted and entered-in-error that mark the communication as not currently valid.
   */
  public status: fhir.FhirCode<EventStatusCodeType>|null;
  /**
   * This element is labeled as a modifier because it marks the communication as a communication that did not occur.  The more attributes are populated, the more constrained the negated statement is.
   */
  public notDone?: fhir.FhirBoolean|undefined;
  /**
   * Describes why the communication event did not occur in coded and/or textual form.
   */
  public notDoneReason?: fhir.CodeableConcept|undefined;
  /**
   * There may be multiple axes of categorization and one communication may serve multiple purposes.
   */
  public category: fhir.CodeableConcept[];
  /**
   * A channel that was used for this communication (e.g. email, fax).
   */
  public medium: fhir.CodeableConcept[];
  /**
   * The patient or group that was the focus of this communication.
   */
  public subject?: fhir.Reference|undefined;
  /**
   * The entity (e.g. person, organization, clinical information system, or device) which was the target of the communication. If receipts need to be tracked by individual, a separate resource instance will need to be created for each recipient.  Multiple recipient communications are intended where either a receipt(s) is not tracked (e.g. a mass mail-out) or is captured in aggregate (all emails confirmed received by a particular time).
   */
  public recipient: fhir.Reference[];
  /**
   * The resources which were responsible for or related to producing this communication.
   */
  public topic: fhir.Reference[];
  /**
   * The encounter within which the communication was sent.
   */
  public context?: fhir.Reference|undefined;
  /**
   * The time when this communication was sent.
   */
  public sent?: fhir.FhirDateTime|undefined;
  /**
   * The time when this communication arrived at the destination.
   */
  public received?: fhir.FhirDateTime|undefined;
  /**
   * The entity (e.g. person, organization, clinical information system, or device) which was the source of the communication.
   */
  public sender?: fhir.Reference|undefined;
  /**
   * Textual reasons can be caprued using reasonCode.text.
   */
  public reasonCode: fhir.CodeableConcept[];
  /**
   * Indicates another resource whose existence justifies this communication.
   */
  public reasonReference: fhir.Reference[];
  /**
   * Text, attachment(s), or resource(s) that was communicated to the recipient.
   */
  public payload: fhir.CommunicationPayload[];
  /**
   * Additional notes or commentary about the communication by the sender, receiver or other interested parties.
   */
  public note: fhir.Annotation[];
  /**
   * Default constructor for Communication - initializes any required elements to null if a value is not provided.
   */
  constructor(source:Partial<CommunicationArgs> = {}, options:fhir.FhirConstructorOptions = {}) {
    super(source, options);
    this.resourceType = 'Communication';
    if (source['identifier']) { this.identifier = source.identifier.map((x) => new fhir.Identifier(x)); }
    else { this.identifier = []; }
    if (source['definition']) { this.definition = source.definition.map((x) => new fhir.Reference(x)); }
    else { this.definition = []; }
    if (source['basedOn']) { this.basedOn = source.basedOn.map((x) => new fhir.Reference(x)); }
    else { this.basedOn = []; }
    if (source['partOf']) { this.partOf = source.partOf.map((x) => new fhir.Reference(x)); }
    else { this.partOf = []; }
    if (source['status']) { this.status = new fhir.FhirCode<EventStatusCodeType>({value: source.status}); }
    else { this.status = null; }
    if (source['_status']) {
      if (this.status) { this.status.addExtendedProperties(source._status!); }
      else { this.status = new fhir.FhirCode<EventStatusCodeType>(source._status as Partial<fhir.FhirCode>); }
    }
    if (source['notDone']) { this.notDone = new fhir.FhirBoolean({value: source.notDone}); }
    if (source['_notDone']) {
      if (this.notDone) { this.notDone.addExtendedProperties(source._notDone!); }
      else { this.notDone = new fhir.FhirBoolean(source._notDone as Partial<fhir.FhirBooleanArgs>); }
    }
    if (source['notDoneReason']) { this.notDoneReason = new fhir.CodeableConcept(source.notDoneReason); }
    if (source['category']) { this.category = source.category.map((x) => new fhir.CodeableConcept(x)); }
    else { this.category = []; }
    if (source['medium']) { this.medium = source.medium.map((x) => new fhir.CodeableConcept(x)); }
    else { this.medium = []; }
    if (source['subject']) { this.subject = new fhir.Reference(source.subject); }
    if (source['recipient']) { this.recipient = source.recipient.map((x) => new fhir.Reference(x)); }
    else { this.recipient = []; }
    if (source['topic']) { this.topic = source.topic.map((x) => new fhir.Reference(x)); }
    else { this.topic = []; }
    if (source['context']) { this.context = new fhir.Reference(source.context); }
    if (source['sent']) { this.sent = new fhir.FhirDateTime({value: source.sent}); }
    if (source['_sent']) {
      if (this.sent) { this.sent.addExtendedProperties(source._sent!); }
      else { this.sent = new fhir.FhirDateTime(source._sent as Partial<fhir.FhirDateTimeArgs>); }
    }
    if (source['received']) { this.received = new fhir.FhirDateTime({value: source.received}); }
    if (source['_received']) {
      if (this.received) { this.received.addExtendedProperties(source._received!); }
      else { this.received = new fhir.FhirDateTime(source._received as Partial<fhir.FhirDateTimeArgs>); }
    }
    if (source['sender']) { this.sender = new fhir.Reference(source.sender); }
    if (source['reasonCode']) { this.reasonCode = source.reasonCode.map((x) => new fhir.CodeableConcept(x)); }
    else { this.reasonCode = []; }
    if (source['reasonReference']) { this.reasonReference = source.reasonReference.map((x) => new fhir.Reference(x)); }
    else { this.reasonReference = []; }
    if (source['payload']) { this.payload = source.payload.map((x) => new fhir.CommunicationPayload(x)); }
    else { this.payload = []; }
    if (source['note']) { this.note = source.note.map((x) => new fhir.Annotation(x)); }
    else { this.note = []; }
  }
  /**
   * Function to perform basic model validation (e.g., check if required elements are present).
   */
  public override doModelValidation(exp:string = ''):fhir.FtsIssue[] {
    let iss:fhir.FtsIssue[] = super.doModelValidation(exp);
    if (exp === '') { exp = 'Communication' }
    iss.push(...this.vOA('identifier',exp));
    iss.push(...this.vOA('definition',exp));
    iss.push(...this.vOA('basedOn',exp));
    iss.push(...this.vOA('partOf',exp));
    iss.push(...this.vRSV('status',exp,'EventStatus',EventStatusVsValidation,'r'));
    iss.push(...this.vOS('notDone',exp));
    iss.push(...this.vOS('notDoneReason',exp));
    iss.push(...this.vOA('category',exp));
    iss.push(...this.vOA('medium',exp));
    iss.push(...this.vOS('subject',exp));
    iss.push(...this.vOA('recipient',exp));
    iss.push(...this.vOA('topic',exp));
    iss.push(...this.vOS('context',exp));
    iss.push(...this.vOS('sent',exp));
    iss.push(...this.vOS('received',exp));
    iss.push(...this.vOS('sender',exp));
    iss.push(...this.vOA('reasonCode',exp));
    iss.push(...this.vOA('reasonReference',exp));
    iss.push(...this.vOA('payload',exp));
    iss.push(...this.vOA('note',exp));
    return iss;
  }
}
